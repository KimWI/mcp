//
// MSX CAS Packager
// Copyright (c) 2015 Alvaro Polo
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

use std::io::Read;
use std::io::Error as IoError;
use std::str::from_utf8;

/// A block of data contained in a tape. 
///
/// A tape file is comprised by a sequence of blocks. Each block starts with the prefix bytes
/// `1fa6debacc137d74` followed by the block data. The `Block` type stores the block data
/// without the prefix bytes. 
///
#[derive(Debug)]
pub struct Block { 
    data: Vec<u8>, 
}

impl Block {

    /// Generates a new block from the data bytes (without the prefix bytes).
    pub fn from_data(bytes: &[u8]) -> Block {
        Block { data: Vec::from(bytes) }
    }
 
    /// Returns the block data (without the prefix bytes).
    pub fn data(&self) -> &[u8] { &self.data[..] }

    /// Returns `true` if the block is detected as a binary header.
    ///
    /// A bin header is comprised by `0xd0d0d0d0d0d0d0d0d0d0` followed by six bytes for
    /// the name of the binary file. This function returns `true` if the block data match
    /// this pattern, `false` otherwise. 
    pub fn is_bin_header(&self) -> bool {
        self.data.len() == 16 && 
            self.data[..10] == [0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0]
    }

    /// Returns the file name in case of a binary, ascii or basic header, `None` otherwise. 
    pub fn file_name(&self) -> Option<&str> {
        if self.is_bin_header() { 
            let name = &self.data[10..16];
            let mut last = 6;
            for i in (0..6).rev() {
                if name[i] == 0 { last = i }
            }
            from_utf8(&name[..last]).ok() 
        } 
        else { None }
    }
}

/// A file contained in a tape
///
/// Files stored in a tape can be one of:
/// * Binary files. They contain binary code and/or data. They are loaded using `BLOAD` 
///   instruction from Basic. 
/// * ASCII files. They contain text, typically corresponding to Basic source code. They are
///   loaded using `LOAD` instruction from Basic. 
/// * Basic files. They contain tokenized Basic, a compact form of Basic source code. They are
///   loaded using `CLOAD` instruction from Basic. 
/// * Custom files. They contain arbitrary data generated by a program using direct calls to
///   casette IO addresses. Its contents cannot be processed from Basic but loaded from the
///   program that generates them in a custom way. 
///
/// `File` instances are generated in iteration from `files()` function of `Tape` type. 
///
#[derive(Debug, PartialEq)]
pub enum File<'a> {
	Bin(String, usize, usize, usize, &'a[u8]),
    Custom(&'a[u8])
}

/// An iterator over the files of a `Tape`
pub struct Files<'a> {
    tape: &'a Tape,
    i: usize,
}

impl<'a> Iterator for Files<'a> {
    
    type Item = File<'a>;
    
    fn next(&mut self) -> Option<File<'a>> {
        while self.i < self.tape.blocks.len() {
            let block = &self.tape.blocks[self.i];
            if block.is_bin_header() {
                let name = block.file_name().unwrap().to_string();
                let content = &self.tape.blocks[self.i+1].data;
                let begin = (content[0] as usize) | (content[1] as usize) << 8;
                let end = (content[2] as usize) | (content[3] as usize) << 8;
                let start = (content[4] as usize) | (content[5] as usize) << 8;
                let data = &content[6..];
                self.i = self.i + 2;
                return Some(File::Bin(name, begin, end, start, data));
            } else {
                self.i = self.i + 1;
                return Some(File::Custom(&block.data[..]));
            }
        }
        None
    }
}

/// An MSX tape. 
///
/// A tape is a sequence of byte blocks (see `Blocks` for more details). The blocks may be
/// grouped such as the tape is seen as a sequence of files through `files()` method. 
///
#[derive(Debug)]
pub struct Tape {
    blocks: Vec<Block>,
}

impl Tape {

    /// Read a `Tape` instance from the given `Read` object. 
    ///
    /// This function returns a new `Tape` instance as result of processing the 
    /// contents of the `Read` passed as argument (e.g., a file), or an `std::io::Error`
    /// if there is an error while reading. 
    ///
	#[allow(dead_code)]
	pub fn read(input: &mut Read) -> Result<Tape, IoError> {
		let mut bytes: Vec<u8> = vec![];
		try!(input.read_to_end(&mut bytes));
		Ok(Tape::from_bytes(&bytes[..]))
	}

    /// Read a `Tape` instance from the given bytes. 
    ///
    /// This function returns a new `Tape` instance as result of processing the bytes passed
    /// as argument. 
	pub fn from_bytes(bytes: &[u8]) -> Tape {
		Tape { blocks: Tape::parse_blocks(bytes) }
	}

    /// Return the files contained in the tape. 
    ///
    /// This function returns an `Iterator` over the files found in the tape blocks. 
    ///
    pub fn files(&self) -> Files { Files { tape: self, i: 0 } }

    fn parse_blocks(bytes: &[u8]) -> Vec<Block> {
        let mut blocks: Vec<Block> = vec![];
        let mut hindex: Vec<usize> = vec![];
        let mut i = 0;

        // First of all, we compute the indices of all block headers.
        for win in bytes.windows(8) {
            if win == [0x1f, 0xa6, 0xde, 0xba, 0xcc, 0x13, 0x7d, 0x74] {
                hindex.push(i);
            }
            i = i + 1;
        }

        // Now we use the block header indices to generate the blocks
        for i in 0..hindex.len() {
            let from = hindex[i] + 8;
            let to = if i == hindex.len() - 1 { bytes.len() } else { hindex[i+1] };
            let block = Block::from_data(&bytes[from..to]);
            blocks.push(block);
        }
        blocks
    }
}

#[cfg(test)]
mod test {

    use super::*;

    macro_rules! assert_bin {
        ($f:expr, $n:expr, $b:expr, $e:expr, $s:expr, $d:expr) => {
            match $f {
            &File::Bin(ref name, begin, end, start, data) => {
                assert_eq!($n, name);
                assert_eq!($b, begin);
                assert_eq!($e, end);
                assert_eq!($s, start);
                assert_eq!($d, &data[..]);
            },
            _ => panic!("unexpected file"),
        }
        }
    }

    #[test]
    fn should_detect_bin_header_block() {
        let bytes: Vec<u8> = vec![
            0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0,
            0x46, 0x4f, 0x4f, 0x42, 0x41, 0x52,
        ];
        let block = Block::from_data(&bytes);
        assert!(block.is_bin_header());
        assert_eq!("FOOBAR", block.file_name().unwrap());
    }

    #[test]
    fn should_detect_block_with_short_name() {
        let bytes: Vec<u8> = vec![
            0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0,
            0x46, 0x4f, 0x4f, 0x00, 0x00, 0x00,
        ];
        let block = Block::from_data(&bytes);
        assert!(block.is_bin_header());
        assert_eq!("FOO", block.file_name().unwrap());        
    }

    #[test]
    fn should_load_empty_tape() {
    	let bytes: Vec<u8> = vec![];
    	let tape = Tape::from_bytes(&bytes);
        assert_eq!(None, tape.files().next());
    }

    #[test]
    fn should_load_bin_file() {
        let bytes: Vec<u8> = vec![
            0x1f, 0xa6, 0xde, 0xba, 0xcc, 0x13, 0x7d, 0x74,
            0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0,
            0x46, 0x4f, 0x4f, 0x42, 0x41, 0x52,
            0x1f, 0xa6, 0xde, 0xba, 0xcc, 0x13, 0x7d, 0x74,
            0x00, 0x80, 0x08, 0x80, 0x00, 0x00,
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
        ];
        let tape = Tape::from_bytes(&bytes);        
        for f in tape.files() {
            assert_bin!(&f, 
                "FOOBAR", 0x8000, 0x8008, 0x0000, &[0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07]);
        } 
    } 
}
